// <auto-generated>
// This code was auto-generated by a tool, every time
// the tool executes this code will be reset.
//
// If you need to extend the classes generated to add
// fields or methods to them, please create partial
// declarations in another file.
// </auto-generated>
#pragma warning disable 0109
#pragma warning disable 1591


namespace Quantum {
  using Photon.Deterministic;
  using Quantum;
  using Quantum.Core;
  using Quantum.Collections;
  using Quantum.Inspector;
  using Quantum.Physics2D;
  using Quantum.Physics3D;
  using Byte = System.Byte;
  using SByte = System.SByte;
  using Int16 = System.Int16;
  using UInt16 = System.UInt16;
  using Int32 = System.Int32;
  using UInt32 = System.UInt32;
  using Int64 = System.Int64;
  using UInt64 = System.UInt64;
  using Boolean = System.Boolean;
  using String = System.String;
  using Object = System.Object;
  using FlagsAttribute = System.FlagsAttribute;
  using SerializableAttribute = System.SerializableAttribute;
  using MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;
  using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
  using FieldOffsetAttribute = System.Runtime.InteropServices.FieldOffsetAttribute;
  using StructLayoutAttribute = System.Runtime.InteropServices.StructLayoutAttribute;
  using LayoutKind = System.Runtime.InteropServices.LayoutKind;
  #if QUANTUM_UNITY //;
  using TooltipAttribute = UnityEngine.TooltipAttribute;
  using HeaderAttribute = UnityEngine.HeaderAttribute;
  using SpaceAttribute = UnityEngine.SpaceAttribute;
  using RangeAttribute = UnityEngine.RangeAttribute;
  using HideInInspectorAttribute = UnityEngine.HideInInspector;
  using PreserveAttribute = UnityEngine.Scripting.PreserveAttribute;
  using FormerlySerializedAsAttribute = UnityEngine.Serialization.FormerlySerializedAsAttribute;
  using MovedFromAttribute = UnityEngine.Scripting.APIUpdating.MovedFromAttribute;
  using CreateAssetMenu = UnityEngine.CreateAssetMenuAttribute;
  using RuntimeInitializeOnLoadMethodAttribute = UnityEngine.RuntimeInitializeOnLoadMethodAttribute;
  #endif //;
  
  public enum EAttributeType : byte {
    None = 0,
    Health = 1,
    Energy = 2,
    Speed = 3,
    Special = 4,
    Stun = 5,
    Rage = 6,
    Power = 7,
  }
  public enum EHealthStatus : byte {
    None,
    Low,
    Medium,
    High,
  }
  public enum EMemoryType : byte {
    None = 1,
    EnemyInsivible = 2,
    HideSpot = 3,
    AreaAvoidance = 4,
    LineAvoidance = 5,
  }
  public enum EModifierAppliance : byte {
    None = 0,
    OneTime = 1,
    Continuous = 2,
    Temporary = 3,
    TemporaryGreatestOnly = 4,
  }
  public enum EModifierOperation : byte {
    None = 0,
    Add = 1,
    Subtract = 2,
  }
  public enum ETactics : byte {
    None,
    Engage,
    Ambush,
    Collect,
    Run,
    Hide,
    TakeCover,
    GuardObjective,
  }
  [Flags()]
  public enum ETeamStatus : byte {
    None = 1,
    Winning = 2,
    SafelyWinning = 4,
    LowHealth = 8,
    MidHealth = 16,
    HighHealth = 32,
  }
  public enum GameState : int {
    None,
    CharacterSelection,
    Playing,
    Over,
  }
  [System.FlagsAttribute()]
  public enum InputButtons : int {
    _left = 1 << 0,
    _right = 1 << 1,
    _up = 1 << 2,
    _down = 1 << 3,
    _a = 1 << 4,
    _b = 1 << 5,
    _c = 1 << 6,
    _d = 1 << 7,
    _l1 = 1 << 8,
    _r1 = 1 << 9,
    _select = 1 << 10,
    _start = 1 << 11,
  }
  public static unsafe partial class FlagsExtensions {
    public static Boolean IsFlagSet(this InputButtons self, InputButtons flag) {
      return (self & flag) == flag;
    }
    public static InputButtons SetFlag(this InputButtons self, InputButtons flag) {
      return self | flag;
    }
    public static InputButtons ClearFlag(this InputButtons self, InputButtons flag) {
      return self & ~flag;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet128 {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[2];
    public const Int32 BitsSize = 128;
    public Int32 Length {
      get {
        return 128;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet128*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 128, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet128 FromArray(UInt64[] values) {
      Assert.Always(2 == values.Length, "Invalid array size", values.Length);
      BitSet128 result = default;
      for (int i = 0; i < 2; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 16);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 4463;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 2);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet128*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 2);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet2048 {
    public const Int32 SIZE = 256;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[32];
    public const Int32 BitsSize = 2048;
    public Int32 Length {
      get {
        return 2048;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet2048*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 2048, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet2048 FromArray(UInt64[] values) {
      Assert.Always(32 == values.Length, "Invalid array size", values.Length);
      BitSet2048 result = default;
      for (int i = 0; i < 32; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 256);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 3319;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 32);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet2048*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 32);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet256 {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[4];
    public const Int32 BitsSize = 256;
    public Int32 Length {
      get {
        return 256;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet256*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 256, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet256 FromArray(UInt64[] values) {
      Assert.Always(4 == values.Length, "Invalid array size", values.Length);
      BitSet256 result = default;
      for (int i = 0; i < 4; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 32);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 14057;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 4);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet256*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 4);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet4096 {
    public const Int32 SIZE = 512;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[64];
    public const Int32 BitsSize = 4096;
    public Int32 Length {
      get {
        return 4096;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet4096*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 4096, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet4096 FromArray(UInt64[] values) {
      Assert.Always(64 == values.Length, "Invalid array size", values.Length);
      BitSet4096 result = default;
      for (int i = 0; i < 64; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 512);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 1433;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 64);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet4096*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 64);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet512 {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[8];
    public const Int32 BitsSize = 512;
    public Int32 Length {
      get {
        return 512;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet512*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 512, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet512 FromArray(UInt64[] values) {
      Assert.Always(8 == values.Length, "Invalid array size", values.Length);
      BitSet512 result = default;
      for (int i = 0; i < 8; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 64);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 17491;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 8);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet512*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 8);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet6 {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[1];
    public const Int32 BitsSize = 6;
    public Int32 Length {
      get {
        return 6;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet6*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 6, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet6 FromArray(UInt64[] values) {
      Assert.Always(1 == values.Length, "Invalid array size", values.Length);
      BitSet6 result = default;
      for (int i = 0; i < 1; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 6);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 6);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 8);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 13669;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 1);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet6*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 1);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct AIDirector {
    public const Int32 SIZE = 12;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public Byte TickInterval;
    [FieldOffset(8)]
    public Int32 TeamIndex;
    [FieldOffset(1)]
    public AIDirectorMemory Memory;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 16411;
        hash = hash * 31 + TickInterval.GetHashCode();
        hash = hash * 31 + TeamIndex.GetHashCode();
        hash = hash * 31 + Memory.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AIDirector*)ptr;
        serializer.Stream.Serialize(&p->TickInterval);
        Quantum.AIDirectorMemory.Serialize(&p->Memory, serializer);
        serializer.Stream.Serialize(&p->TeamIndex);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct AIDirectorMemory {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 1;
    [FieldOffset(1)]
    private fixed Byte _alignment_padding_[3];
    [FieldOffset(0)]
    public Byte AvailableCoins;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 11317;
        hash = hash * 31 + AvailableCoins.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AIDirectorMemory*)ptr;
        serializer.Stream.Serialize(&p->AvailableCoins);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct AIMemoryEntry {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public EMemoryType Type;
    [FieldOffset(16)]
    public MemoryData Data;
    [FieldOffset(12)]
    public QBoolean IsInfinite;
    [FieldOffset(4)]
    public Int32 AvailableTick;
    [FieldOffset(8)]
    public Int32 UnavailableTick;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 11351;
        hash = hash * 31 + (Byte)Type;
        hash = hash * 31 + Data.GetHashCode();
        hash = hash * 31 + IsInfinite.GetHashCode();
        hash = hash * 31 + AvailableTick.GetHashCode();
        hash = hash * 31 + UnavailableTick.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AIMemoryEntry*)ptr;
        serializer.Stream.Serialize((Byte*)&p->Type);
        serializer.Stream.Serialize(&p->AvailableTick);
        serializer.Stream.Serialize(&p->UnavailableTick);
        QBoolean.Serialize(&p->IsInfinite, serializer);
        Quantum.MemoryData.Serialize(&p->Data, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ArcherSpecialAttackRD {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FPVector2 TargetPosition;
    [FieldOffset(0)]
    public FP EffectInterval;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 4373;
        hash = hash * 31 + TargetPosition.GetHashCode();
        hash = hash * 31 + EffectInterval.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ArcherSpecialAttackRD*)ptr;
        FP.Serialize(&p->EffectInterval, serializer);
        FPVector2.Serialize(&p->TargetPosition, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct AttributeData {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public FP InitialValue;
    [FieldOffset(24)]
    public FP MaxValue;
    [FieldOffset(8)]
    [HideInInspector()]
    public FP CurrentValue;
    [FieldOffset(0)]
    public QListPtr<AttributeModifier> Modifiers;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 17497;
        hash = hash * 31 + InitialValue.GetHashCode();
        hash = hash * 31 + MaxValue.GetHashCode();
        hash = hash * 31 + CurrentValue.GetHashCode();
        hash = hash * 31 + Modifiers.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      Modifiers = default;
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AttributeData*)ptr;
        QList.Serialize(&p->Modifiers, serializer, Statics.SerializeAttributeModifier);
        FP.Serialize(&p->CurrentValue, serializer);
        FP.Serialize(&p->InitialValue, serializer);
        FP.Serialize(&p->MaxValue, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct AttributeModifier {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public EModifierAppliance ModifierAppliance;
    [FieldOffset(1)]
    public EModifierOperation ModifierOperation;
    [FieldOffset(8)]
    public FP Amount;
    [FieldOffset(16)]
    public FP Duration;
    [FieldOffset(24)]
    [HideInInspector()]
    public FP Timer;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 14867;
        hash = hash * 31 + (Byte)ModifierAppliance;
        hash = hash * 31 + (Byte)ModifierOperation;
        hash = hash * 31 + Amount.GetHashCode();
        hash = hash * 31 + Duration.GetHashCode();
        hash = hash * 31 + Timer.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AttributeModifier*)ptr;
        serializer.Stream.Serialize((Byte*)&p->ModifierAppliance);
        serializer.Stream.Serialize((Byte*)&p->ModifierOperation);
        FP.Serialize(&p->Amount, serializer);
        FP.Serialize(&p->Duration, serializer);
        FP.Serialize(&p->Timer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Input {
    public const Int32 SIZE = 160;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(76)]
    public Button _left;
    [FieldOffset(100)]
    public Button _right;
    [FieldOffset(136)]
    public Button _up;
    [FieldOffset(52)]
    public Button _down;
    [FieldOffset(4)]
    public Button _a;
    [FieldOffset(16)]
    public Button _b;
    [FieldOffset(28)]
    public Button _c;
    [FieldOffset(40)]
    public Button _d;
    [FieldOffset(64)]
    public Button _l1;
    [FieldOffset(88)]
    public Button _r1;
    [FieldOffset(112)]
    public Button _select;
    [FieldOffset(124)]
    public Button _start;
    [FieldOffset(1)]
    public Byte _analogRightTrigger;
    [FieldOffset(0)]
    public Byte _analogLeftTrigger;
    [FieldOffset(148)]
    public QuantumThumbSticks ThumbSticks;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 19249;
        hash = hash * 31 + _left.GetHashCode();
        hash = hash * 31 + _right.GetHashCode();
        hash = hash * 31 + _up.GetHashCode();
        hash = hash * 31 + _down.GetHashCode();
        hash = hash * 31 + _a.GetHashCode();
        hash = hash * 31 + _b.GetHashCode();
        hash = hash * 31 + _c.GetHashCode();
        hash = hash * 31 + _d.GetHashCode();
        hash = hash * 31 + _l1.GetHashCode();
        hash = hash * 31 + _r1.GetHashCode();
        hash = hash * 31 + _select.GetHashCode();
        hash = hash * 31 + _start.GetHashCode();
        hash = hash * 31 + _analogRightTrigger.GetHashCode();
        hash = hash * 31 + _analogLeftTrigger.GetHashCode();
        hash = hash * 31 + ThumbSticks.GetHashCode();
        return hash;
      }
    }
    static partial void GetMaxCountCodeGen(ref int maxCount) {
      maxCount = 6;
    }
    public Boolean IsDown(InputButtons button) {
      switch (button) {
        case InputButtons._left: return _left.IsDown;
        case InputButtons._right: return _right.IsDown;
        case InputButtons._up: return _up.IsDown;
        case InputButtons._down: return _down.IsDown;
        case InputButtons._a: return _a.IsDown;
        case InputButtons._b: return _b.IsDown;
        case InputButtons._c: return _c.IsDown;
        case InputButtons._d: return _d.IsDown;
        case InputButtons._l1: return _l1.IsDown;
        case InputButtons._r1: return _r1.IsDown;
        case InputButtons._select: return _select.IsDown;
        case InputButtons._start: return _start.IsDown;
        default: return false;
      }
    }
    public Boolean WasPressed(InputButtons button) {
      switch (button) {
        case InputButtons._left: return _left.WasPressed;
        case InputButtons._right: return _right.WasPressed;
        case InputButtons._up: return _up.WasPressed;
        case InputButtons._down: return _down.WasPressed;
        case InputButtons._a: return _a.WasPressed;
        case InputButtons._b: return _b.WasPressed;
        case InputButtons._c: return _c.WasPressed;
        case InputButtons._d: return _d.WasPressed;
        case InputButtons._l1: return _l1.WasPressed;
        case InputButtons._r1: return _r1.WasPressed;
        case InputButtons._select: return _select.WasPressed;
        case InputButtons._start: return _start.WasPressed;
        default: return false;
      }
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (Input*)ptr;
        serializer.Stream.Serialize(&p->_analogLeftTrigger);
        serializer.Stream.Serialize(&p->_analogRightTrigger);
        Button.Serialize(&p->_a, serializer);
        Button.Serialize(&p->_b, serializer);
        Button.Serialize(&p->_c, serializer);
        Button.Serialize(&p->_d, serializer);
        Button.Serialize(&p->_down, serializer);
        Button.Serialize(&p->_l1, serializer);
        Button.Serialize(&p->_left, serializer);
        Button.Serialize(&p->_r1, serializer);
        Button.Serialize(&p->_right, serializer);
        Button.Serialize(&p->_select, serializer);
        Button.Serialize(&p->_start, serializer);
        Button.Serialize(&p->_up, serializer);
        Quantum.QuantumThumbSticks.Serialize(&p->ThumbSticks, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KnightBasicAttackRD {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public EntityRef SkillEntity;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 10903;
        hash = hash * 31 + SkillEntity.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KnightBasicAttackRD*)ptr;
        EntityRef.Serialize(&p->SkillEntity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KnightBasicSkillRD {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(4)]
    public QListPtr<EntityRef> Attacks;
    [FieldOffset(0)]
    public QListPtr<EntityRef> AlreadyAffected;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 21193;
        hash = hash * 31 + Attacks.GetHashCode();
        hash = hash * 31 + AlreadyAffected.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      Attacks = default;
      AlreadyAffected = default;
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KnightBasicSkillRD*)ptr;
        QList.Serialize(&p->AlreadyAffected, serializer, Statics.SerializeEntityRef);
        QList.Serialize(&p->Attacks, serializer, Statics.SerializeEntityRef);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KnightSpecialAttackRD {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public QListPtr<EntityRef> Targets;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 19583;
        hash = hash * 31 + Targets.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      Targets = default;
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KnightSpecialAttackRD*)ptr;
        QList.Serialize(&p->Targets, serializer, Statics.SerializeEntityRef);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct MemoryDataAreaAvoidance {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public FP Weight;
    [FieldOffset(0)]
    public EntityRef Entity;
    [FieldOffset(8)]
    public FP RunDistance;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 1601;
        hash = hash * 31 + Weight.GetHashCode();
        hash = hash * 31 + Entity.GetHashCode();
        hash = hash * 31 + RunDistance.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (MemoryDataAreaAvoidance*)ptr;
        EntityRef.Serialize(&p->Entity, serializer);
        FP.Serialize(&p->RunDistance, serializer);
        FP.Serialize(&p->Weight, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct MemoryDataEnemyInvisible {
    public const Int32 SIZE = 40;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public EntityRef Enemy;
    [FieldOffset(8)]
    public FPVector2 DisappearPosition;
    [FieldOffset(24)]
    public FPVector2 NearbyHideSpot;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 5303;
        hash = hash * 31 + Enemy.GetHashCode();
        hash = hash * 31 + DisappearPosition.GetHashCode();
        hash = hash * 31 + NearbyHideSpot.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (MemoryDataEnemyInvisible*)ptr;
        EntityRef.Serialize(&p->Enemy, serializer);
        FPVector2.Serialize(&p->DisappearPosition, serializer);
        FPVector2.Serialize(&p->NearbyHideSpot, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct MemoryDataLineAvoidance {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FP Weight;
    [FieldOffset(0)]
    public EntityRef Entity;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 12473;
        hash = hash * 31 + Weight.GetHashCode();
        hash = hash * 31 + Entity.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (MemoryDataLineAvoidance*)ptr;
        EntityRef.Serialize(&p->Entity, serializer);
        FP.Serialize(&p->Weight, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct QuantumDemoInputPlatformer2D {
    public const Int32 SIZE = 128;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(112)]
    public FPVector2 AimDirection;
    [FieldOffset(60)]
    public Button Left;
    [FieldOffset(72)]
    public Button Right;
    [FieldOffset(84)]
    public Button Up;
    [FieldOffset(24)]
    public Button Down;
    [FieldOffset(48)]
    public Button Jump;
    [FieldOffset(12)]
    public Button Dash;
    [FieldOffset(36)]
    public Button Fire;
    [FieldOffset(0)]
    public Button AltFire;
    [FieldOffset(96)]
    public Button Use;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 17191;
        hash = hash * 31 + AimDirection.GetHashCode();
        hash = hash * 31 + Left.GetHashCode();
        hash = hash * 31 + Right.GetHashCode();
        hash = hash * 31 + Up.GetHashCode();
        hash = hash * 31 + Down.GetHashCode();
        hash = hash * 31 + Jump.GetHashCode();
        hash = hash * 31 + Dash.GetHashCode();
        hash = hash * 31 + Fire.GetHashCode();
        hash = hash * 31 + AltFire.GetHashCode();
        hash = hash * 31 + Use.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (QuantumDemoInputPlatformer2D*)ptr;
        Button.Serialize(&p->AltFire, serializer);
        Button.Serialize(&p->Dash, serializer);
        Button.Serialize(&p->Down, serializer);
        Button.Serialize(&p->Fire, serializer);
        Button.Serialize(&p->Jump, serializer);
        Button.Serialize(&p->Left, serializer);
        Button.Serialize(&p->Right, serializer);
        Button.Serialize(&p->Up, serializer);
        Button.Serialize(&p->Use, serializer);
        FPVector2.Serialize(&p->AimDirection, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct QuantumDemoInputShooter3D {
    public const Int32 SIZE = 96;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(80)]
    public FPVector2 MoveDirection;
    [FieldOffset(0)]
    public FP Pitch;
    [FieldOffset(8)]
    public FP Yaw;
    [FieldOffset(52)]
    public Button Jump;
    [FieldOffset(28)]
    public Button Dash;
    [FieldOffset(40)]
    public Button Fire;
    [FieldOffset(16)]
    public Button AltFire;
    [FieldOffset(64)]
    public Button Use;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 15511;
        hash = hash * 31 + MoveDirection.GetHashCode();
        hash = hash * 31 + Pitch.GetHashCode();
        hash = hash * 31 + Yaw.GetHashCode();
        hash = hash * 31 + Jump.GetHashCode();
        hash = hash * 31 + Dash.GetHashCode();
        hash = hash * 31 + Fire.GetHashCode();
        hash = hash * 31 + AltFire.GetHashCode();
        hash = hash * 31 + Use.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (QuantumDemoInputShooter3D*)ptr;
        FP.Serialize(&p->Pitch, serializer);
        FP.Serialize(&p->Yaw, serializer);
        Button.Serialize(&p->AltFire, serializer);
        Button.Serialize(&p->Dash, serializer);
        Button.Serialize(&p->Fire, serializer);
        Button.Serialize(&p->Jump, serializer);
        Button.Serialize(&p->Use, serializer);
        FPVector2.Serialize(&p->MoveDirection, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct QuantumDemoInputTopDown {
    public const Int32 SIZE = 144;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(128)]
    public FPVector2 MoveDirection;
    [FieldOffset(112)]
    public FPVector2 AimDirection;
    [FieldOffset(60)]
    public Button Left;
    [FieldOffset(72)]
    public Button Right;
    [FieldOffset(84)]
    public Button Up;
    [FieldOffset(24)]
    public Button Down;
    [FieldOffset(48)]
    public Button Jump;
    [FieldOffset(12)]
    public Button Dash;
    [FieldOffset(36)]
    public Button Fire;
    [FieldOffset(0)]
    public Button AltFire;
    [FieldOffset(96)]
    public Button Use;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 5501;
        hash = hash * 31 + MoveDirection.GetHashCode();
        hash = hash * 31 + AimDirection.GetHashCode();
        hash = hash * 31 + Left.GetHashCode();
        hash = hash * 31 + Right.GetHashCode();
        hash = hash * 31 + Up.GetHashCode();
        hash = hash * 31 + Down.GetHashCode();
        hash = hash * 31 + Jump.GetHashCode();
        hash = hash * 31 + Dash.GetHashCode();
        hash = hash * 31 + Fire.GetHashCode();
        hash = hash * 31 + AltFire.GetHashCode();
        hash = hash * 31 + Use.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (QuantumDemoInputTopDown*)ptr;
        Button.Serialize(&p->AltFire, serializer);
        Button.Serialize(&p->Dash, serializer);
        Button.Serialize(&p->Down, serializer);
        Button.Serialize(&p->Fire, serializer);
        Button.Serialize(&p->Jump, serializer);
        Button.Serialize(&p->Left, serializer);
        Button.Serialize(&p->Right, serializer);
        Button.Serialize(&p->Up, serializer);
        Button.Serialize(&p->Use, serializer);
        FPVector2.Serialize(&p->AimDirection, serializer);
        FPVector2.Serialize(&p->MoveDirection, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct QuantumHighresThumbSticks {
    public const Int32 SIZE = 6;
    public const Int32 ALIGNMENT = 2;
    [FieldOffset(0)]
    public Byte _leftThumbAngle;
    [FieldOffset(1)]
    public Byte _leftThumbMagnitude;
    [FieldOffset(2)]
    public Int16 _rightThumbX;
    [FieldOffset(4)]
    public Int16 _rightThumbY;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 18181;
        hash = hash * 31 + _leftThumbAngle.GetHashCode();
        hash = hash * 31 + _leftThumbMagnitude.GetHashCode();
        hash = hash * 31 + _rightThumbX.GetHashCode();
        hash = hash * 31 + _rightThumbY.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (QuantumHighresThumbSticks*)ptr;
        serializer.Stream.Serialize(&p->_leftThumbAngle);
        serializer.Stream.Serialize(&p->_leftThumbMagnitude);
        serializer.Stream.Serialize(&p->_rightThumbX);
        serializer.Stream.Serialize(&p->_rightThumbY);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [ExcludeFromPrototype()]
  public unsafe partial struct QuantumRegularThumbSticks {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 1;
    [FieldOffset(0)]
    public Byte _leftThumbAngle;
    [FieldOffset(1)]
    public Byte _leftThumbMagnitude;
    [FieldOffset(2)]
    public Byte _rightThumbAngle;
    [FieldOffset(3)]
    public Byte _rightThumbMagnitude;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 2731;
        hash = hash * 31 + _leftThumbAngle.GetHashCode();
        hash = hash * 31 + _leftThumbMagnitude.GetHashCode();
        hash = hash * 31 + _rightThumbAngle.GetHashCode();
        hash = hash * 31 + _rightThumbMagnitude.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (QuantumRegularThumbSticks*)ptr;
        serializer.Stream.Serialize(&p->_leftThumbAngle);
        serializer.Stream.Serialize(&p->_leftThumbMagnitude);
        serializer.Stream.Serialize(&p->_rightThumbAngle);
        serializer.Stream.Serialize(&p->_rightThumbMagnitude);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct SpellcasterBasicAttackRD {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FPVector2 TargetPosition;
    [FieldOffset(0)]
    public FP EffectInterval;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 653;
        hash = hash * 31 + TargetPosition.GetHashCode();
        hash = hash * 31 + EffectInterval.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SpellcasterBasicAttackRD*)ptr;
        FP.Serialize(&p->EffectInterval, serializer);
        FPVector2.Serialize(&p->TargetPosition, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct SpellcasterSpecialAttackRD {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FPVector2 TargetPosition;
    [FieldOffset(0)]
    public FP EffectInterval;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 2657;
        hash = hash * 31 + TargetPosition.GetHashCode();
        hash = hash * 31 + EffectInterval.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SpellcasterSpecialAttackRD*)ptr;
        FP.Serialize(&p->EffectInterval, serializer);
        FPVector2.Serialize(&p->TargetPosition, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct SpellcasterSpecialSkillRD {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public FPVector2 TargetPosition;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 16231;
        hash = hash * 31 + TargetPosition.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SpellcasterSpecialSkillRD*)ptr;
        FPVector2.Serialize(&p->TargetPosition, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct SteeringEntryContext {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public EntityRef CharacterRef;
    [FieldOffset(8)]
    public FP RunDistance;
    [FieldOffset(16)]
    public FP ThreatDistance;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 6911;
        hash = hash * 31 + CharacterRef.GetHashCode();
        hash = hash * 31 + RunDistance.GetHashCode();
        hash = hash * 31 + ThreatDistance.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SteeringEntryContext*)ptr;
        EntityRef.Serialize(&p->CharacterRef, serializer);
        FP.Serialize(&p->RunDistance, serializer);
        FP.Serialize(&p->ThreatDistance, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct SteeringEntryNavMesh {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public FPVector2 NavMeshDirection;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 2273;
        hash = hash * 31 + NavMeshDirection.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SteeringEntryNavMesh*)ptr;
        FPVector2.Serialize(&p->NavMeshDirection, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct TeamData {
    public const Int32 SIZE = 72;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(68)]
    private fixed Byte _alignment_padding_[4];
    [FieldOffset(0)]
    public Byte Index;
    [FieldOffset(12)]
    public QBoolean StrategyFightActivated;
    [FieldOffset(20)]
    public QBoolean StrategyScoreActivated;
    [FieldOffset(16)]
    public QBoolean StrategyRunActivated;
    [FieldOffset(4)]
    public Int32 Score;
    [FieldOffset(40)]
    public FP HealthsMax;
    [FieldOffset(32)]
    public FP HealthsCurrent;
    [FieldOffset(24)]
    public FP HealthsAverage;
    [FieldOffset(48)]
    public FP HealthsPercentage;
    [FieldOffset(8)]
    public QBoolean HasLowScoreAgent;
    [FieldOffset(1)]
    public ETeamStatus TeamStatus;
    [FieldOffset(56)]
    public AIDirector AIDirector;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 9629;
        hash = hash * 31 + Index.GetHashCode();
        hash = hash * 31 + StrategyFightActivated.GetHashCode();
        hash = hash * 31 + StrategyScoreActivated.GetHashCode();
        hash = hash * 31 + StrategyRunActivated.GetHashCode();
        hash = hash * 31 + Score.GetHashCode();
        hash = hash * 31 + HealthsMax.GetHashCode();
        hash = hash * 31 + HealthsCurrent.GetHashCode();
        hash = hash * 31 + HealthsAverage.GetHashCode();
        hash = hash * 31 + HealthsPercentage.GetHashCode();
        hash = hash * 31 + HasLowScoreAgent.GetHashCode();
        hash = hash * 31 + (Byte)TeamStatus;
        hash = hash * 31 + AIDirector.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (TeamData*)ptr;
        serializer.Stream.Serialize(&p->Index);
        serializer.Stream.Serialize((Byte*)&p->TeamStatus);
        serializer.Stream.Serialize(&p->Score);
        QBoolean.Serialize(&p->HasLowScoreAgent, serializer);
        QBoolean.Serialize(&p->StrategyFightActivated, serializer);
        QBoolean.Serialize(&p->StrategyRunActivated, serializer);
        QBoolean.Serialize(&p->StrategyScoreActivated, serializer);
        FP.Serialize(&p->HealthsAverage, serializer);
        FP.Serialize(&p->HealthsCurrent, serializer);
        FP.Serialize(&p->HealthsMax, serializer);
        FP.Serialize(&p->HealthsPercentage, serializer);
        Quantum.AIDirector.Serialize(&p->AIDirector, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct _globals_ {
    public const Int32 SIZE = 1664;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<Map> Map;
    [FieldOffset(8)]
    public FP DeltaTime;
    [FieldOffset(16)]
    public NavMeshRegionMask NavMeshRegions;
    [FieldOffset(32)]
    public PhysicsEngineState PhysicsState2D;
    [FieldOffset(48)]
    public PhysicsEngineState PhysicsState3D;
    [FieldOffset(64)]
    public RNGSession RngSession;
    [FieldOffset(80)]
    public FrameMetaData FrameMetaData;
    [FieldOffset(128)]
    public BitSet1024 Systems;
    [FieldOffset(256)]
    public PhysicsSceneSettings PhysicsSettings;
    [FieldOffset(552)]
    public Int32 PlayerConnectedCount;
    [FieldOffset(556)]
    [FramePrinter.FixedArrayAttribute(typeof(Input), 6)]
    private fixed Byte _input_[960];
    [FieldOffset(1520)]
    public BitSet6 PlayerLastConnectionState;
    [FieldOffset(1560)]
    public FP TimeToFillWithBots;
    [FieldOffset(1552)]
    public FP MatchTimer;
    [FieldOffset(1544)]
    public FP MatchDuration;
    [FieldOffset(1532)]
    public QBoolean ControllersEnabled;
    [FieldOffset(1528)]
    public GameState State;
    [FieldOffset(1568)]
    public HFSMData GameManagerHFSM;
    [FieldOffset(1536)]
    public QDictionaryPtr<Int32, EntityRef> InvisibilitySpots;
    [FieldOffset(1540)]
    public QListPtr<TeamData> TeamsData;
    public FixedArray<Input> input {
      get {
        fixed (byte* p = _input_) { return new FixedArray<Input>(p, 160, 6); }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 12473;
        hash = hash * 31 + Map.GetHashCode();
        hash = hash * 31 + DeltaTime.GetHashCode();
        hash = hash * 31 + NavMeshRegions.GetHashCode();
        hash = hash * 31 + PhysicsState2D.GetHashCode();
        hash = hash * 31 + PhysicsState3D.GetHashCode();
        hash = hash * 31 + RngSession.GetHashCode();
        hash = hash * 31 + FrameMetaData.GetHashCode();
        hash = hash * 31 + Systems.GetHashCode();
        hash = hash * 31 + PhysicsSettings.GetHashCode();
        hash = hash * 31 + PlayerConnectedCount.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(input);
        hash = hash * 31 + PlayerLastConnectionState.GetHashCode();
        hash = hash * 31 + TimeToFillWithBots.GetHashCode();
        hash = hash * 31 + MatchTimer.GetHashCode();
        hash = hash * 31 + MatchDuration.GetHashCode();
        hash = hash * 31 + ControllersEnabled.GetHashCode();
        hash = hash * 31 + (Int32)State;
        hash = hash * 31 + GameManagerHFSM.GetHashCode();
        hash = hash * 31 + InvisibilitySpots.GetHashCode();
        hash = hash * 31 + TeamsData.GetHashCode();
        return hash;
      }
    }
    partial void ClearPointersPartial(FrameBase f, EntityRef entity) {
      InvisibilitySpots = default;
      TeamsData = default;
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (_globals_*)ptr;
        AssetRef.Serialize(&p->Map, serializer);
        FP.Serialize(&p->DeltaTime, serializer);
        NavMeshRegionMask.Serialize(&p->NavMeshRegions, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState2D, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState3D, serializer);
        RNGSession.Serialize(&p->RngSession, serializer);
        FrameMetaData.Serialize(&p->FrameMetaData, serializer);
        Quantum.BitSet1024.Serialize(&p->Systems, serializer);
        PhysicsSceneSettings.Serialize(&p->PhysicsSettings, serializer);
        serializer.Stream.Serialize(&p->PlayerConnectedCount);
        FixedArray.Serialize(p->input, serializer, Statics.SerializeInput);
        Quantum.BitSet6.Serialize(&p->PlayerLastConnectionState, serializer);
        serializer.Stream.Serialize((Int32*)&p->State);
        QBoolean.Serialize(&p->ControllersEnabled, serializer);
        QDictionary.Serialize(&p->InvisibilitySpots, serializer, Statics.SerializeInt32, Statics.SerializeEntityRef);
        QList.Serialize(&p->TeamsData, serializer, Statics.SerializeTeamData);
        FP.Serialize(&p->MatchDuration, serializer);
        FP.Serialize(&p->MatchTimer, serializer);
        FP.Serialize(&p->TimeToFillWithBots, serializer);
        HFSMData.Serialize(&p->GameManagerHFSM, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Union()]
  public unsafe partial struct AttackRuntimeData {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    private Int32 _field_used_;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.AttackRuntimeData.ARCHERSPECIALATTACKRD)]
    private ArcherSpecialAttackRD _ArcherSpecialAttackRD;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.AttackRuntimeData.SPELLCASTERBASICATTACKRD)]
    private SpellcasterBasicAttackRD _SpellcasterBasicAttackRD;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.AttackRuntimeData.SPELLCASTERSPECIALATTACKRD)]
    private SpellcasterSpecialAttackRD _SpellcasterSpecialAttackRD;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.AttackRuntimeData.KNIGHTBASICATTACKRD)]
    private KnightBasicAttackRD _KnightBasicAttackRD;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.AttackRuntimeData.KNIGHTSPECIALATTACKRD)]
    private KnightSpecialAttackRD _KnightSpecialAttackRD;
    public const Int32 ARCHERSPECIALATTACKRD = 1;
    public const Int32 SPELLCASTERBASICATTACKRD = 2;
    public const Int32 SPELLCASTERSPECIALATTACKRD = 3;
    public const Int32 KNIGHTBASICATTACKRD = 4;
    public const Int32 KNIGHTSPECIALATTACKRD = 5;
    public Int32 Field {
      get {
        return _field_used_;
      }
    }
    public ArcherSpecialAttackRD* ArcherSpecialAttackRD {
      get {
        fixed (ArcherSpecialAttackRD* p = &_ArcherSpecialAttackRD) {
          if (_field_used_ != ARCHERSPECIALATTACKRD) {
            Native.Utils.Clear(p, 24);
            _field_used_ = ARCHERSPECIALATTACKRD;
          }
          return p;
        }
      }
    }
    public SpellcasterBasicAttackRD* SpellcasterBasicAttackRD {
      get {
        fixed (SpellcasterBasicAttackRD* p = &_SpellcasterBasicAttackRD) {
          if (_field_used_ != SPELLCASTERBASICATTACKRD) {
            Native.Utils.Clear(p, 24);
            _field_used_ = SPELLCASTERBASICATTACKRD;
          }
          return p;
        }
      }
    }
    public SpellcasterSpecialAttackRD* SpellcasterSpecialAttackRD {
      get {
        fixed (SpellcasterSpecialAttackRD* p = &_SpellcasterSpecialAttackRD) {
          if (_field_used_ != SPELLCASTERSPECIALATTACKRD) {
            Native.Utils.Clear(p, 24);
            _field_used_ = SPELLCASTERSPECIALATTACKRD;
          }
          return p;
        }
      }
    }
    public KnightBasicAttackRD* KnightBasicAttackRD {
      get {
        fixed (KnightBasicAttackRD* p = &_KnightBasicAttackRD) {
          if (_field_used_ != KNIGHTBASICATTACKRD) {
            Native.Utils.Clear(p, 8);
            _field_used_ = KNIGHTBASICATTACKRD;
          }
          return p;
        }
      }
    }
    public KnightSpecialAttackRD* KnightSpecialAttackRD {
      get {
        fixed (KnightSpecialAttackRD* p = &_KnightSpecialAttackRD) {
          if (_field_used_ != KNIGHTSPECIALATTACKRD) {
            Native.Utils.Clear(p, 4);
            _field_used_ = KNIGHTSPECIALATTACKRD;
          }
          return p;
        }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 7573;
        hash = hash * 31 + _field_used_.GetHashCode();
        hash = hash * 31 + _ArcherSpecialAttackRD.GetHashCode();
        hash = hash * 31 + _SpellcasterBasicAttackRD.GetHashCode();
        hash = hash * 31 + _SpellcasterSpecialAttackRD.GetHashCode();
        hash = hash * 31 + _KnightBasicAttackRD.GetHashCode();
        hash = hash * 31 + _KnightSpecialAttackRD.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      if (_field_used_ == KNIGHTSPECIALATTACKRD) {
        _KnightSpecialAttackRD.ClearPointers(f, entity);
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AttackRuntimeData*)ptr;
        if (serializer.InputMode) {
          serializer.Stream.SerializeBuffer((byte*)p, Quantum.AttackRuntimeData.SIZE);
          return;
        }
        serializer.Stream.Serialize(&p->_field_used_);
        if (p->_field_used_ == ARCHERSPECIALATTACKRD) {
          Quantum.ArcherSpecialAttackRD.Serialize(&p->_ArcherSpecialAttackRD, serializer);
        }
        if (p->_field_used_ == KNIGHTBASICATTACKRD) {
          Quantum.KnightBasicAttackRD.Serialize(&p->_KnightBasicAttackRD, serializer);
        }
        if (p->_field_used_ == KNIGHTSPECIALATTACKRD) {
          Quantum.KnightSpecialAttackRD.Serialize(&p->_KnightSpecialAttackRD, serializer);
        }
        if (p->_field_used_ == SPELLCASTERBASICATTACKRD) {
          Quantum.SpellcasterBasicAttackRD.Serialize(&p->_SpellcasterBasicAttackRD, serializer);
        }
        if (p->_field_used_ == SPELLCASTERSPECIALATTACKRD) {
          Quantum.SpellcasterSpecialAttackRD.Serialize(&p->_SpellcasterSpecialAttackRD, serializer);
        }
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Union()]
  public unsafe partial struct MemoryData {
    public const Int32 SIZE = 48;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    private Int32 _field_used_;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.MemoryData.ENEMYINVISIBLE)]
    private MemoryDataEnemyInvisible _EnemyInvisible;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.MemoryData.AREAAVOIDANCE)]
    private MemoryDataAreaAvoidance _AreaAvoidance;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.MemoryData.LINEAVOIDANCE)]
    private MemoryDataLineAvoidance _LineAvoidance;
    public const Int32 ENEMYINVISIBLE = 1;
    public const Int32 AREAAVOIDANCE = 2;
    public const Int32 LINEAVOIDANCE = 3;
    public Int32 Field {
      get {
        return _field_used_;
      }
    }
    public MemoryDataEnemyInvisible* EnemyInvisible {
      get {
        fixed (MemoryDataEnemyInvisible* p = &_EnemyInvisible) {
          if (_field_used_ != ENEMYINVISIBLE) {
            Native.Utils.Clear(p, 40);
            _field_used_ = ENEMYINVISIBLE;
          }
          return p;
        }
      }
    }
    public MemoryDataAreaAvoidance* AreaAvoidance {
      get {
        fixed (MemoryDataAreaAvoidance* p = &_AreaAvoidance) {
          if (_field_used_ != AREAAVOIDANCE) {
            Native.Utils.Clear(p, 24);
            _field_used_ = AREAAVOIDANCE;
          }
          return p;
        }
      }
    }
    public MemoryDataLineAvoidance* LineAvoidance {
      get {
        fixed (MemoryDataLineAvoidance* p = &_LineAvoidance) {
          if (_field_used_ != LINEAVOIDANCE) {
            Native.Utils.Clear(p, 16);
            _field_used_ = LINEAVOIDANCE;
          }
          return p;
        }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 20297;
        hash = hash * 31 + _field_used_.GetHashCode();
        hash = hash * 31 + _EnemyInvisible.GetHashCode();
        hash = hash * 31 + _AreaAvoidance.GetHashCode();
        hash = hash * 31 + _LineAvoidance.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (MemoryData*)ptr;
        if (serializer.InputMode) {
          serializer.Stream.SerializeBuffer((byte*)p, Quantum.MemoryData.SIZE);
          return;
        }
        serializer.Stream.Serialize(&p->_field_used_);
        if (p->_field_used_ == AREAAVOIDANCE) {
          Quantum.MemoryDataAreaAvoidance.Serialize(&p->_AreaAvoidance, serializer);
        }
        if (p->_field_used_ == ENEMYINVISIBLE) {
          Quantum.MemoryDataEnemyInvisible.Serialize(&p->_EnemyInvisible, serializer);
        }
        if (p->_field_used_ == LINEAVOIDANCE) {
          Quantum.MemoryDataLineAvoidance.Serialize(&p->_LineAvoidance, serializer);
        }
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Union()]
  [ExcludeFromPrototype()]
  public unsafe partial struct QuantumThumbSticks {
    public const Int32 SIZE = 12;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(10)]
    private fixed Byte _alignment_padding_[2];
    [FieldOffset(0)]
    private Int32 _field_used_;
    [FieldOffset(4)]
    [FieldOverlap(4)]
    [FramePrinter.PrintIf("_field_used_", Quantum.QuantumThumbSticks.REGULAR)]
    private QuantumRegularThumbSticks _Regular;
    [FieldOffset(4)]
    [FieldOverlap(4)]
    [FramePrinter.PrintIf("_field_used_", Quantum.QuantumThumbSticks.HIGHRES)]
    private QuantumHighresThumbSticks _HighRes;
    public const Int32 REGULAR = 1;
    public const Int32 HIGHRES = 2;
    public Int32 Field {
      get {
        return _field_used_;
      }
    }
    public QuantumRegularThumbSticks* Regular {
      get {
        fixed (QuantumRegularThumbSticks* p = &_Regular) {
          if (_field_used_ != REGULAR) {
            Native.Utils.Clear(p, 4);
            _field_used_ = REGULAR;
          }
          return p;
        }
      }
    }
    public QuantumHighresThumbSticks* HighRes {
      get {
        fixed (QuantumHighresThumbSticks* p = &_HighRes) {
          if (_field_used_ != HIGHRES) {
            Native.Utils.Clear(p, 6);
            _field_used_ = HIGHRES;
          }
          return p;
        }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 8867;
        hash = hash * 31 + _field_used_.GetHashCode();
        hash = hash * 31 + _Regular.GetHashCode();
        hash = hash * 31 + _HighRes.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (QuantumThumbSticks*)ptr;
        if (serializer.InputMode) {
          serializer.Stream.SerializeBuffer((byte*)p, Quantum.QuantumThumbSticks.SIZE);
          return;
        }
        serializer.Stream.Serialize(&p->_field_used_);
        if (p->_field_used_ == HIGHRES) {
          Quantum.QuantumHighresThumbSticks.Serialize(&p->_HighRes, serializer);
        }
        if (p->_field_used_ == REGULAR) {
          Quantum.QuantumRegularThumbSticks.Serialize(&p->_Regular, serializer);
        }
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Union()]
  public unsafe partial struct SkillRuntimeData {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    private Int32 _field_used_;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.SkillRuntimeData.KNIGHTBASICSKILLRD)]
    private KnightBasicSkillRD _KnightBasicSkillRD;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.SkillRuntimeData.SPELLCASTERSPECIALSKILLRD)]
    private SpellcasterSpecialSkillRD _SpellcasterSpecialSkillRD;
    public const Int32 KNIGHTBASICSKILLRD = 1;
    public const Int32 SPELLCASTERSPECIALSKILLRD = 2;
    public Int32 Field {
      get {
        return _field_used_;
      }
    }
    public KnightBasicSkillRD* KnightBasicSkillRD {
      get {
        fixed (KnightBasicSkillRD* p = &_KnightBasicSkillRD) {
          if (_field_used_ != KNIGHTBASICSKILLRD) {
            Native.Utils.Clear(p, 8);
            _field_used_ = KNIGHTBASICSKILLRD;
          }
          return p;
        }
      }
    }
    public SpellcasterSpecialSkillRD* SpellcasterSpecialSkillRD {
      get {
        fixed (SpellcasterSpecialSkillRD* p = &_SpellcasterSpecialSkillRD) {
          if (_field_used_ != SPELLCASTERSPECIALSKILLRD) {
            Native.Utils.Clear(p, 16);
            _field_used_ = SPELLCASTERSPECIALSKILLRD;
          }
          return p;
        }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 8017;
        hash = hash * 31 + _field_used_.GetHashCode();
        hash = hash * 31 + _KnightBasicSkillRD.GetHashCode();
        hash = hash * 31 + _SpellcasterSpecialSkillRD.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      if (_field_used_ == KNIGHTBASICSKILLRD) {
        _KnightBasicSkillRD.ClearPointers(f, entity);
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SkillRuntimeData*)ptr;
        if (serializer.InputMode) {
          serializer.Stream.SerializeBuffer((byte*)p, Quantum.SkillRuntimeData.SIZE);
          return;
        }
        serializer.Stream.Serialize(&p->_field_used_);
        if (p->_field_used_ == KNIGHTBASICSKILLRD) {
          Quantum.KnightBasicSkillRD.Serialize(&p->_KnightBasicSkillRD, serializer);
        }
        if (p->_field_used_ == SPELLCASTERSPECIALSKILLRD) {
          Quantum.SpellcasterSpecialSkillRD.Serialize(&p->_SpellcasterSpecialSkillRD, serializer);
        }
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Union()]
  public unsafe partial struct SteeringData {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    private Int32 _field_used_;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.SteeringData.STEERINGENTRYNAVMESH)]
    private SteeringEntryNavMesh _SteeringEntryNavMesh;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.SteeringData.STEERINGENTRYCONTEXT)]
    private SteeringEntryContext _SteeringEntryContext;
    public const Int32 STEERINGENTRYNAVMESH = 1;
    public const Int32 STEERINGENTRYCONTEXT = 2;
    public Int32 Field {
      get {
        return _field_used_;
      }
    }
    public SteeringEntryNavMesh* SteeringEntryNavMesh {
      get {
        fixed (SteeringEntryNavMesh* p = &_SteeringEntryNavMesh) {
          if (_field_used_ != STEERINGENTRYNAVMESH) {
            Native.Utils.Clear(p, 16);
            _field_used_ = STEERINGENTRYNAVMESH;
          }
          return p;
        }
      }
    }
    public SteeringEntryContext* SteeringEntryContext {
      get {
        fixed (SteeringEntryContext* p = &_SteeringEntryContext) {
          if (_field_used_ != STEERINGENTRYCONTEXT) {
            Native.Utils.Clear(p, 24);
            _field_used_ = STEERINGENTRYCONTEXT;
          }
          return p;
        }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 17581;
        hash = hash * 31 + _field_used_.GetHashCode();
        hash = hash * 31 + _SteeringEntryNavMesh.GetHashCode();
        hash = hash * 31 + _SteeringEntryContext.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SteeringData*)ptr;
        if (serializer.InputMode) {
          serializer.Stream.SerializeBuffer((byte*)p, Quantum.SteeringData.SIZE);
          return;
        }
        serializer.Stream.Serialize(&p->_field_used_);
        if (p->_field_used_ == STEERINGENTRYCONTEXT) {
          Quantum.SteeringEntryContext.Serialize(&p->_SteeringEntryContext, serializer);
        }
        if (p->_field_used_ == STEERINGENTRYNAVMESH) {
          Quantum.SteeringEntryNavMesh.Serialize(&p->_SteeringEntryNavMesh, serializer);
        }
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct AIMemory : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(4)]
    public QListPtr<AIMemoryEntry> MemoryEntries;
    [FieldOffset(0)]
    public EHealthStatus HealthStatus;
    [FieldOffset(8)]
    public EntityRef ClosestCoin;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 17477;
        hash = hash * 31 + MemoryEntries.GetHashCode();
        hash = hash * 31 + (Byte)HealthStatus;
        hash = hash * 31 + ClosestCoin.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      MemoryEntries = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.AIMemory*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AIMemory*)ptr;
        serializer.Stream.Serialize((Byte*)&p->HealthStatus);
        QList.Serialize(&p->MemoryEntries, serializer, Statics.SerializeAIMemoryEntry);
        EntityRef.Serialize(&p->ClosestCoin, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct AISteering : Quantum.IComponent {
    public const Int32 SIZE = 112;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(4)]
    public QBoolean Debug;
    [FieldOffset(80)]
    [HideInInspector()]
    public SteeringData MainSteeringData;
    [FieldOffset(48)]
    [HideInInspector()]
    public FPVector2 CurrentDirection;
    [FieldOffset(40)]
    public FP MaxEvasionDuration;
    [FieldOffset(16)]
    [HideInInspector()]
    public FP EvasionTimer;
    [FieldOffset(0)]
    [HideInInspector()]
    public Int32 EvasionDirection;
    [FieldOffset(64)]
    [HideInInspector()]
    public FPVector2 EvasionDirectionVector;
    [FieldOffset(32)]
    public FP MainSteeringWeight;
    [FieldOffset(8)]
    public FP AvoidanceWeight;
    [FieldOffset(24)]
    public FP LerpFactor;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 19231;
        hash = hash * 31 + Debug.GetHashCode();
        hash = hash * 31 + MainSteeringData.GetHashCode();
        hash = hash * 31 + CurrentDirection.GetHashCode();
        hash = hash * 31 + MaxEvasionDuration.GetHashCode();
        hash = hash * 31 + EvasionTimer.GetHashCode();
        hash = hash * 31 + EvasionDirection.GetHashCode();
        hash = hash * 31 + EvasionDirectionVector.GetHashCode();
        hash = hash * 31 + MainSteeringWeight.GetHashCode();
        hash = hash * 31 + AvoidanceWeight.GetHashCode();
        hash = hash * 31 + LerpFactor.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AISteering*)ptr;
        serializer.Stream.Serialize(&p->EvasionDirection);
        QBoolean.Serialize(&p->Debug, serializer);
        FP.Serialize(&p->AvoidanceWeight, serializer);
        FP.Serialize(&p->EvasionTimer, serializer);
        FP.Serialize(&p->LerpFactor, serializer);
        FP.Serialize(&p->MainSteeringWeight, serializer);
        FP.Serialize(&p->MaxEvasionDuration, serializer);
        FPVector2.Serialize(&p->CurrentDirection, serializer);
        FPVector2.Serialize(&p->EvasionDirectionVector, serializer);
        Quantum.SteeringData.Serialize(&p->MainSteeringData, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Attack : Quantum.IComponent {
    public const Int32 SIZE = 56;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<AttackData> AttackData;
    [FieldOffset(24)]
    public AttackRuntimeData AttackRuntimeData;
    [FieldOffset(8)]
    public EntityRef Source;
    [FieldOffset(16)]
    public FP TTL;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 467;
        hash = hash * 31 + AttackData.GetHashCode();
        hash = hash * 31 + AttackRuntimeData.GetHashCode();
        hash = hash * 31 + Source.GetHashCode();
        hash = hash * 31 + TTL.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      AttackRuntimeData.ClearPointers(f, entity);
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.Attack*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Attack*)ptr;
        AssetRef.Serialize(&p->AttackData, serializer);
        EntityRef.Serialize(&p->Source, serializer);
        FP.Serialize(&p->TTL, serializer);
        Quantum.AttackRuntimeData.Serialize(&p->AttackRuntimeData, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Attributes : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public QDictionaryPtr<EAttributeType, AttributeData> DataDictionary;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 12043;
        hash = hash * 31 + DataDictionary.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      DataDictionary = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.Attributes*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Attributes*)ptr;
        QDictionary.Serialize(&p->DataDictionary, serializer, Statics.SerializeEAttributeType, Statics.SerializeAttributeData);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Bot : Quantum.IComponent {
    public const Int32 SIZE = 192;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(4)]
    public QBoolean IsActive;
    [FieldOffset(48)]
    [HideInInspector()]
    public QuantumDemoInputTopDown Input;
    [FieldOffset(24)]
    public AssetRef<HFSMRoot> HFSMRoot;
    [FieldOffset(8)]
    public AssetRef<AIBlackboardInitializer> BlackboardInitializer;
    [FieldOffset(16)]
    public AssetRef<AIConfigBase> AIConfig;
    [FieldOffset(32)]
    public AssetRef<NavMeshAgentConfig> NavMeshAgentConfig;
    [FieldOffset(0)]
    public ETactics CurrentTactic;
    [FieldOffset(40)]
    public FP TacticalCommitment;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 419;
        hash = hash * 31 + IsActive.GetHashCode();
        hash = hash * 31 + Input.GetHashCode();
        hash = hash * 31 + HFSMRoot.GetHashCode();
        hash = hash * 31 + BlackboardInitializer.GetHashCode();
        hash = hash * 31 + AIConfig.GetHashCode();
        hash = hash * 31 + NavMeshAgentConfig.GetHashCode();
        hash = hash * 31 + (Byte)CurrentTactic;
        hash = hash * 31 + TacticalCommitment.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Bot*)ptr;
        serializer.Stream.Serialize((Byte*)&p->CurrentTactic);
        QBoolean.Serialize(&p->IsActive, serializer);
        AssetRef.Serialize(&p->BlackboardInitializer, serializer);
        AssetRef.Serialize(&p->AIConfig, serializer);
        AssetRef.Serialize(&p->HFSMRoot, serializer);
        AssetRef.Serialize(&p->NavMeshAgentConfig, serializer);
        FP.Serialize(&p->TacticalCommitment, serializer);
        Quantum.QuantumDemoInputTopDown.Serialize(&p->Input, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Character : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<CharacterInfo> Info;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 13711;
        hash = hash * 31 + Info.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Character*)ptr;
        AssetRef.Serialize(&p->Info, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct CharacterAttacks : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<SkillData> BasicSkillData;
    [FieldOffset(8)]
    public AssetRef<SkillData> SpecialSkillData;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 14621;
        hash = hash * 31 + BasicSkillData.GetHashCode();
        hash = hash * 31 + SpecialSkillData.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CharacterAttacks*)ptr;
        AssetRef.Serialize(&p->BasicSkillData, serializer);
        AssetRef.Serialize(&p->SpecialSkillData, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Collectible : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<CollectibleData> CollectibleData;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 1279;
        hash = hash * 31 + CollectibleData.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Collectible*)ptr;
        AssetRef.Serialize(&p->CollectibleData, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct EscapeRoute : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public Int32 TeamId;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 9643;
        hash = hash * 31 + TeamId.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (EscapeRoute*)ptr;
        serializer.Stream.Serialize(&p->TeamId);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Health : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(4)]
    public QBoolean IsDead;
    [FieldOffset(0)]
    public QBoolean CanSelfHeal;
    [FieldOffset(16)]
    [HideInInspector()]
    public FP StartHealingTime;
    [FieldOffset(8)]
    [HideInInspector()]
    public FP NextHealTime;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 2111;
        hash = hash * 31 + IsDead.GetHashCode();
        hash = hash * 31 + CanSelfHeal.GetHashCode();
        hash = hash * 31 + StartHealingTime.GetHashCode();
        hash = hash * 31 + NextHealTime.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Health*)ptr;
        QBoolean.Serialize(&p->CanSelfHeal, serializer);
        QBoolean.Serialize(&p->IsDead, serializer);
        FP.Serialize(&p->NextHealTime, serializer);
        FP.Serialize(&p->StartHealingTime, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Immunity : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [HideInInspector()]
    public FP Timer;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 16127;
        hash = hash * 31 + Timer.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Immunity*)ptr;
        FP.Serialize(&p->Timer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct InputContainer : Quantum.IComponent {
    public const Int32 SIZE = 144;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [HideInInspector()]
    public QuantumDemoInputTopDown Input;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 17387;
        hash = hash * 31 + Input.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (InputContainer*)ptr;
        Quantum.QuantumDemoInputTopDown.Serialize(&p->Input, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Inventory : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public Int32 CollectiblesAmount;
    [FieldOffset(16)]
    public AssetRef<CollectibleData> CollectibleData;
    [FieldOffset(8)]
    public AssetRef<CollectibleData> AttractionCollectibleData;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 1669;
        hash = hash * 31 + CollectiblesAmount.GetHashCode();
        hash = hash * 31 + CollectibleData.GetHashCode();
        hash = hash * 31 + AttractionCollectibleData.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Inventory*)ptr;
        serializer.Stream.Serialize(&p->CollectiblesAmount);
        AssetRef.Serialize(&p->AttractionCollectibleData, serializer);
        AssetRef.Serialize(&p->CollectibleData, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Invisibility : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [HideInInspector()]
    public Int32 InvisibilitySpotsCount;
    [FieldOffset(8)]
    [HideInInspector()]
    public QBoolean IsInvisible;
    [FieldOffset(16)]
    [HideInInspector()]
    public FP ExposureTimer;
    [FieldOffset(4)]
    [HideInInspector()]
    public Int32 StaticColliderId;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 7549;
        hash = hash * 31 + InvisibilitySpotsCount.GetHashCode();
        hash = hash * 31 + IsInvisible.GetHashCode();
        hash = hash * 31 + ExposureTimer.GetHashCode();
        hash = hash * 31 + StaticColliderId.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Invisibility*)ptr;
        serializer.Stream.Serialize(&p->InvisibilitySpotsCount);
        serializer.Stream.Serialize(&p->StaticColliderId);
        QBoolean.Serialize(&p->IsInvisible, serializer);
        FP.Serialize(&p->ExposureTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct InvisibilitySpot : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public Byte GroupId;
    [FieldOffset(16)]
    public Int32 StaticColliderId;
    [FieldOffset(8)]
    public Int32 NorthNeighborId;
    [FieldOffset(12)]
    public Int32 SouthNeighborId;
    [FieldOffset(4)]
    public Int32 EastNeighborId;
    [FieldOffset(20)]
    public Int32 WestNeighborId;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 10651;
        hash = hash * 31 + GroupId.GetHashCode();
        hash = hash * 31 + StaticColliderId.GetHashCode();
        hash = hash * 31 + NorthNeighborId.GetHashCode();
        hash = hash * 31 + SouthNeighborId.GetHashCode();
        hash = hash * 31 + EastNeighborId.GetHashCode();
        hash = hash * 31 + WestNeighborId.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (InvisibilitySpot*)ptr;
        serializer.Stream.Serialize(&p->GroupId);
        serializer.Stream.Serialize(&p->EastNeighborId);
        serializer.Stream.Serialize(&p->NorthNeighborId);
        serializer.Stream.Serialize(&p->SouthNeighborId);
        serializer.Stream.Serialize(&p->StaticColliderId);
        serializer.Stream.Serialize(&p->WestNeighborId);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KCC : Quantum.IComponent {
    public const Int32 SIZE = 40;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<KCCSettings> Settings;
    [FieldOffset(16)]
    public FP MaxSpeed;
    [FieldOffset(8)]
    public FP Acceleration;
    [FieldOffset(24)]
    public FPVector2 Velocity;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 659;
        hash = hash * 31 + Settings.GetHashCode();
        hash = hash * 31 + MaxSpeed.GetHashCode();
        hash = hash * 31 + Acceleration.GetHashCode();
        hash = hash * 31 + Velocity.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KCC*)ptr;
        AssetRef.Serialize(&p->Settings, serializer);
        FP.Serialize(&p->Acceleration, serializer);
        FP.Serialize(&p->MaxSpeed, serializer);
        FPVector2.Serialize(&p->Velocity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct MovementData : Quantum.IComponent {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [HideInInspector()]
    public FP DirectionTimer;
    [FieldOffset(8)]
    [HideInInspector()]
    public FP MovementTimer;
    [FieldOffset(16)]
    [HideInInspector()]
    public FPVector2 LastAutoAimDirection;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 19213;
        hash = hash * 31 + DirectionTimer.GetHashCode();
        hash = hash * 31 + MovementTimer.GetHashCode();
        hash = hash * 31 + LastAutoAimDirection.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (MovementData*)ptr;
        FP.Serialize(&p->DirectionTimer, serializer);
        FP.Serialize(&p->MovementTimer, serializer);
        FPVector2.Serialize(&p->LastAutoAimDirection, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ObjectivePoint : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 19609;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ObjectivePoint*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerLink : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public PlayerRef PlayerRef;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 21391;
        hash = hash * 31 + PlayerRef.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerLink*)ptr;
        PlayerRef.Serialize(&p->PlayerRef, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Respawn : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [HideInInspector()]
    public FP SpawnTimer;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 13411;
        hash = hash * 31 + SpawnTimer.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Respawn*)ptr;
        FP.Serialize(&p->SpawnTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Skill : Quantum.IComponent {
    public const Int32 SIZE = 72;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<SkillData> SkillData;
    [FieldOffset(48)]
    public SkillRuntimeData SkillRuntimeData;
    [FieldOffset(8)]
    public EntityRef Source;
    [FieldOffset(32)]
    public FPVector2 ActionVector;
    [FieldOffset(24)]
    public FP TTL;
    [FieldOffset(16)]
    public FP ActionTimer;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 6287;
        hash = hash * 31 + SkillData.GetHashCode();
        hash = hash * 31 + SkillRuntimeData.GetHashCode();
        hash = hash * 31 + Source.GetHashCode();
        hash = hash * 31 + ActionVector.GetHashCode();
        hash = hash * 31 + TTL.GetHashCode();
        hash = hash * 31 + ActionTimer.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      SkillRuntimeData.ClearPointers(f, entity);
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.Skill*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Skill*)ptr;
        AssetRef.Serialize(&p->SkillData, serializer);
        EntityRef.Serialize(&p->Source, serializer);
        FP.Serialize(&p->ActionTimer, serializer);
        FP.Serialize(&p->TTL, serializer);
        FPVector2.Serialize(&p->ActionVector, serializer);
        Quantum.SkillRuntimeData.Serialize(&p->SkillRuntimeData, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct SpawnPoint : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public Int32 Team;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 12269;
        hash = hash * 31 + Team.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SpawnPoint*)ptr;
        serializer.Stream.Serialize(&p->Team);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct TeamInfo : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public Int32 Index;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 12421;
        hash = hash * 31 + Index.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (TeamInfo*)ptr;
        serializer.Stream.Serialize(&p->Index);
    }
  }
  public unsafe partial interface ISignalOnCreateAttack : ISignal {
    void OnCreateAttack(Frame f, EntityRef attackEntity, Attack* attack);
  }
  public unsafe partial interface ISignalOnDisableAttack : ISignal {
    void OnDisableAttack(Frame f, EntityRef attackEntity);
  }
  public unsafe partial interface ISignalOnCharacterDefeated : ISignal {
    void OnCharacterDefeated(Frame f, EntityRef character);
  }
  public unsafe partial interface ISignalOnSetCharacterImmune : ISignal {
    void OnSetCharacterImmune(Frame f, EntityRef character, FP time);
  }
  public unsafe partial interface ISignalOnCharacterDamage : ISignal {
    void OnCharacterDamage(Frame f, EntityRef character);
  }
  public unsafe partial interface ISignalOnCommandFinishCharacterSelection : ISignal {
    void OnCommandFinishCharacterSelection(Frame f);
  }
  public unsafe partial interface ISignalOnCreatePlayerCharacter : ISignal {
    void OnCreatePlayerCharacter(Frame f, PlayerRef player, AssetRef<EntityPrototype> prototype);
  }
  public unsafe partial interface ISignalOnChangePlayerTeam : ISignal {
    void OnChangePlayerTeam(Frame f, PlayerRef player);
  }
  public unsafe partial interface ISignalOnDestroyPlayerCharacter : ISignal {
    void OnDestroyPlayerCharacter(Frame f, PlayerRef player);
  }
  public unsafe partial interface ISignalOnCharacterSelectionStart : ISignal {
    void OnCharacterSelectionStart(Frame f);
  }
  public unsafe partial interface ISignalOnFinish : ISignal {
    void OnFinish(Frame f);
  }
  public unsafe partial interface ISignalOnGameStart : ISignal {
    void OnGameStart(Frame f);
  }
  public unsafe partial interface ISignalOnToggleControllers : ISignal {
    void OnToggleControllers(Frame f, QBoolean value);
  }
  public unsafe partial interface ISignalOnGameOver : ISignal {
    void OnGameOver(Frame f, QBoolean value);
  }
  public unsafe partial interface ISignalOnRespawnCharacter : ISignal {
    void OnRespawnCharacter(Frame f, EntityRef character, QBoolean IsFirstSpawn);
  }
  public unsafe partial interface ISignalOnCreateSkill : ISignal {
    void OnCreateSkill(Frame f, EntityRef character, FPVector2 characterPos, SkillData data, FPVector2 actionDirection);
  }
  public unsafe partial interface ISignalOnDisableSkill : ISignal {
    void OnDisableSkill(Frame f, EntityRef character, SkillData data);
  }
  public static unsafe partial class Constants {
    public const Int32 MAX_AIM_DISTANCE = 10;
    public const Int32 MAX_TEAM_SIZE = 3;
  }
  public unsafe partial class Frame {
    private ISignalOnCreateAttack[] _ISignalOnCreateAttackSystems;
    private ISignalOnDisableAttack[] _ISignalOnDisableAttackSystems;
    private ISignalOnCharacterDefeated[] _ISignalOnCharacterDefeatedSystems;
    private ISignalOnSetCharacterImmune[] _ISignalOnSetCharacterImmuneSystems;
    private ISignalOnCharacterDamage[] _ISignalOnCharacterDamageSystems;
    private ISignalOnCommandFinishCharacterSelection[] _ISignalOnCommandFinishCharacterSelectionSystems;
    private ISignalOnCreatePlayerCharacter[] _ISignalOnCreatePlayerCharacterSystems;
    private ISignalOnChangePlayerTeam[] _ISignalOnChangePlayerTeamSystems;
    private ISignalOnDestroyPlayerCharacter[] _ISignalOnDestroyPlayerCharacterSystems;
    private ISignalOnCharacterSelectionStart[] _ISignalOnCharacterSelectionStartSystems;
    private ISignalOnFinish[] _ISignalOnFinishSystems;
    private ISignalOnGameStart[] _ISignalOnGameStartSystems;
    private ISignalOnToggleControllers[] _ISignalOnToggleControllersSystems;
    private ISignalOnGameOver[] _ISignalOnGameOverSystems;
    private ISignalOnRespawnCharacter[] _ISignalOnRespawnCharacterSystems;
    private ISignalOnCreateSkill[] _ISignalOnCreateSkillSystems;
    private ISignalOnDisableSkill[] _ISignalOnDisableSkillSystems;
    partial void AllocGen() {
      _globals = (_globals_*)Context.Allocator.AllocAndClear(sizeof(_globals_));
    }
    partial void FreeGen() {
      Context.Allocator.Free(_globals);
    }
    partial void CopyFromGen(Frame frame) {
      Native.Utils.Copy(_globals, frame._globals, sizeof(_globals_));
    }
    partial void InitGen() {
      Initialize(this, this.SimulationConfig.Entities, 256);
      _ISignalOnCreateAttackSystems = BuildSignalsArray<ISignalOnCreateAttack>();
      _ISignalOnDisableAttackSystems = BuildSignalsArray<ISignalOnDisableAttack>();
      _ISignalOnCharacterDefeatedSystems = BuildSignalsArray<ISignalOnCharacterDefeated>();
      _ISignalOnSetCharacterImmuneSystems = BuildSignalsArray<ISignalOnSetCharacterImmune>();
      _ISignalOnCharacterDamageSystems = BuildSignalsArray<ISignalOnCharacterDamage>();
      _ISignalOnCommandFinishCharacterSelectionSystems = BuildSignalsArray<ISignalOnCommandFinishCharacterSelection>();
      _ISignalOnCreatePlayerCharacterSystems = BuildSignalsArray<ISignalOnCreatePlayerCharacter>();
      _ISignalOnChangePlayerTeamSystems = BuildSignalsArray<ISignalOnChangePlayerTeam>();
      _ISignalOnDestroyPlayerCharacterSystems = BuildSignalsArray<ISignalOnDestroyPlayerCharacter>();
      _ISignalOnCharacterSelectionStartSystems = BuildSignalsArray<ISignalOnCharacterSelectionStart>();
      _ISignalOnFinishSystems = BuildSignalsArray<ISignalOnFinish>();
      _ISignalOnGameStartSystems = BuildSignalsArray<ISignalOnGameStart>();
      _ISignalOnToggleControllersSystems = BuildSignalsArray<ISignalOnToggleControllers>();
      _ISignalOnGameOverSystems = BuildSignalsArray<ISignalOnGameOver>();
      _ISignalOnRespawnCharacterSystems = BuildSignalsArray<ISignalOnRespawnCharacter>();
      _ISignalOnCreateSkillSystems = BuildSignalsArray<ISignalOnCreateSkill>();
      _ISignalOnDisableSkillSystems = BuildSignalsArray<ISignalOnDisableSkill>();
      _ComponentSignalsOnAdded = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      _ComponentSignalsOnRemoved = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      BuildSignalsArrayOnComponentAdded<AIBlackboardComponent>();
      BuildSignalsArrayOnComponentRemoved<AIBlackboardComponent>();
      BuildSignalsArrayOnComponentAdded<Quantum.AIMemory>();
      BuildSignalsArrayOnComponentRemoved<Quantum.AIMemory>();
      BuildSignalsArrayOnComponentAdded<Quantum.AISteering>();
      BuildSignalsArrayOnComponentRemoved<Quantum.AISteering>();
      BuildSignalsArrayOnComponentAdded<Quantum.Attack>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Attack>();
      BuildSignalsArrayOnComponentAdded<Quantum.Attributes>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Attributes>();
      BuildSignalsArrayOnComponentAdded<BTAgent>();
      BuildSignalsArrayOnComponentRemoved<BTAgent>();
      BuildSignalsArrayOnComponentAdded<Quantum.Bot>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Bot>();
      BuildSignalsArrayOnComponentAdded<BotSDKGlobals>();
      BuildSignalsArrayOnComponentRemoved<BotSDKGlobals>();
      BuildSignalsArrayOnComponentAdded<Quantum.Character>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Character>();
      BuildSignalsArrayOnComponentAdded<Quantum.CharacterAttacks>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CharacterAttacks>();
      BuildSignalsArrayOnComponentAdded<CharacterController2D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController2D>();
      BuildSignalsArrayOnComponentAdded<CharacterController3D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.Collectible>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Collectible>();
      BuildSignalsArrayOnComponentAdded<Quantum.EscapeRoute>();
      BuildSignalsArrayOnComponentRemoved<Quantum.EscapeRoute>();
      BuildSignalsArrayOnComponentAdded<HFSMAgent>();
      BuildSignalsArrayOnComponentRemoved<HFSMAgent>();
      BuildSignalsArrayOnComponentAdded<Quantum.Health>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Health>();
      BuildSignalsArrayOnComponentAdded<Quantum.Immunity>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Immunity>();
      BuildSignalsArrayOnComponentAdded<Quantum.InputContainer>();
      BuildSignalsArrayOnComponentRemoved<Quantum.InputContainer>();
      BuildSignalsArrayOnComponentAdded<Quantum.Inventory>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Inventory>();
      BuildSignalsArrayOnComponentAdded<Quantum.Invisibility>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Invisibility>();
      BuildSignalsArrayOnComponentAdded<Quantum.InvisibilitySpot>();
      BuildSignalsArrayOnComponentRemoved<Quantum.InvisibilitySpot>();
      BuildSignalsArrayOnComponentAdded<Quantum.KCC>();
      BuildSignalsArrayOnComponentRemoved<Quantum.KCC>();
      BuildSignalsArrayOnComponentAdded<MapEntityLink>();
      BuildSignalsArrayOnComponentRemoved<MapEntityLink>();
      BuildSignalsArrayOnComponentAdded<Quantum.MovementData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.MovementData>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentAdded<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentRemoved<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentAdded<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentAdded<Quantum.ObjectivePoint>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ObjectivePoint>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerLink>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerLink>();
      BuildSignalsArrayOnComponentAdded<Quantum.Respawn>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Respawn>();
      BuildSignalsArrayOnComponentAdded<Quantum.Skill>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Skill>();
      BuildSignalsArrayOnComponentAdded<Quantum.SpawnPoint>();
      BuildSignalsArrayOnComponentRemoved<Quantum.SpawnPoint>();
      BuildSignalsArrayOnComponentAdded<Quantum.TeamInfo>();
      BuildSignalsArrayOnComponentRemoved<Quantum.TeamInfo>();
      BuildSignalsArrayOnComponentAdded<Transform2D>();
      BuildSignalsArrayOnComponentRemoved<Transform2D>();
      BuildSignalsArrayOnComponentAdded<Transform2DVertical>();
      BuildSignalsArrayOnComponentRemoved<Transform2DVertical>();
      BuildSignalsArrayOnComponentAdded<Transform3D>();
      BuildSignalsArrayOnComponentRemoved<Transform3D>();
      BuildSignalsArrayOnComponentAdded<UTAgent>();
      BuildSignalsArrayOnComponentRemoved<UTAgent>();
      BuildSignalsArrayOnComponentAdded<View>();
      BuildSignalsArrayOnComponentRemoved<View>();
    }
    partial void SetPlayerInputCodeGen(PlayerRef player, Input input) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      var i = _globals->input.GetPointer(player);
      i->_left = i->_left.Update(this.Number, input._left);
      i->_right = i->_right.Update(this.Number, input._right);
      i->_up = i->_up.Update(this.Number, input._up);
      i->_down = i->_down.Update(this.Number, input._down);
      i->_a = i->_a.Update(this.Number, input._a);
      i->_b = i->_b.Update(this.Number, input._b);
      i->_c = i->_c.Update(this.Number, input._c);
      i->_d = i->_d.Update(this.Number, input._d);
      i->_l1 = i->_l1.Update(this.Number, input._l1);
      i->_r1 = i->_r1.Update(this.Number, input._r1);
      i->_select = i->_select.Update(this.Number, input._select);
      i->_start = i->_start.Update(this.Number, input._start);
      i->_analogRightTrigger = input._analogRightTrigger;
      i->_analogLeftTrigger = input._analogLeftTrigger;
      i->ThumbSticks = input.ThumbSticks;
    }
    public Input* GetPlayerInput(PlayerRef player) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      return _globals->input.GetPointer(player);
    }
    partial void GetPlayerLastConnectionStateCodeGen(ref BitSetRef bitSet) {
      bitSet = new(_globals->PlayerLastConnectionState.Bits, _globals->PlayerLastConnectionState.Length);
    }
    partial void ResetPhysicsCodeGen() {
      if (Context.Physics2D != null && Physics2D.Map != null && Physics2D.Map.Guid.IsDynamic) Physics2D.ResetMap();
      Physics2D.Init(_globals->PhysicsState2D.MapStaticCollidersState.TrackedMap);
      if (Context.Physics3D != null && Physics3D.Map != null && Physics3D.Map.Guid.IsDynamic) Physics3D.ResetMap();
      Physics3D.Init(_globals->PhysicsState3D.MapStaticCollidersState.TrackedMap);
    }
    public unsafe partial struct FrameSignals {
      public void OnCreateAttack(EntityRef attackEntity, Attack* attack) {
        var array = _f._ISignalOnCreateAttackSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCreateAttack(_f, attackEntity, attack);
          }
        }
      }
      public void OnDisableAttack(EntityRef attackEntity) {
        var array = _f._ISignalOnDisableAttackSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnDisableAttack(_f, attackEntity);
          }
        }
      }
      public void OnCharacterDefeated(EntityRef character) {
        var array = _f._ISignalOnCharacterDefeatedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCharacterDefeated(_f, character);
          }
        }
      }
      public void OnSetCharacterImmune(EntityRef character, FP time) {
        var array = _f._ISignalOnSetCharacterImmuneSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnSetCharacterImmune(_f, character, time);
          }
        }
      }
      public void OnCharacterDamage(EntityRef character) {
        var array = _f._ISignalOnCharacterDamageSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCharacterDamage(_f, character);
          }
        }
      }
      public void OnCommandFinishCharacterSelection() {
        var array = _f._ISignalOnCommandFinishCharacterSelectionSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCommandFinishCharacterSelection(_f);
          }
        }
      }
      public void OnCreatePlayerCharacter(PlayerRef player, AssetRef<EntityPrototype> prototype) {
        var array = _f._ISignalOnCreatePlayerCharacterSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCreatePlayerCharacter(_f, player, prototype);
          }
        }
      }
      public void OnChangePlayerTeam(PlayerRef player) {
        var array = _f._ISignalOnChangePlayerTeamSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnChangePlayerTeam(_f, player);
          }
        }
      }
      public void OnDestroyPlayerCharacter(PlayerRef player) {
        var array = _f._ISignalOnDestroyPlayerCharacterSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnDestroyPlayerCharacter(_f, player);
          }
        }
      }
      public void OnCharacterSelectionStart() {
        var array = _f._ISignalOnCharacterSelectionStartSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCharacterSelectionStart(_f);
          }
        }
      }
      public void OnFinish() {
        var array = _f._ISignalOnFinishSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnFinish(_f);
          }
        }
      }
      public void OnGameStart() {
        var array = _f._ISignalOnGameStartSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnGameStart(_f);
          }
        }
      }
      public void OnToggleControllers(QBoolean value) {
        var array = _f._ISignalOnToggleControllersSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnToggleControllers(_f, value);
          }
        }
      }
      public void OnGameOver(QBoolean value) {
        var array = _f._ISignalOnGameOverSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnGameOver(_f, value);
          }
        }
      }
      public void OnRespawnCharacter(EntityRef character, QBoolean IsFirstSpawn) {
        var array = _f._ISignalOnRespawnCharacterSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnRespawnCharacter(_f, character, IsFirstSpawn);
          }
        }
      }
      public void OnCreateSkill(EntityRef character, FPVector2 characterPos, SkillData data, FPVector2 actionDirection) {
        var array = _f._ISignalOnCreateSkillSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCreateSkill(_f, character, characterPos, data, actionDirection);
          }
        }
      }
      public void OnDisableSkill(EntityRef character, SkillData data) {
        var array = _f._ISignalOnDisableSkillSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnDisableSkill(_f, character, data);
          }
        }
      }
    }
  }
  public unsafe partial class Statics {
    public static FrameSerializer.Delegate SerializeAIMemoryEntry;
    public static FrameSerializer.Delegate SerializeAttributeModifier;
    public static FrameSerializer.Delegate SerializeEAttributeType;
    public static FrameSerializer.Delegate SerializeAttributeData;
    public static FrameSerializer.Delegate SerializeEntityRef;
    public static FrameSerializer.Delegate SerializeInt32;
    public static FrameSerializer.Delegate SerializeTeamData;
    public static FrameSerializer.Delegate SerializeInput;
    static partial void InitStaticDelegatesGen() {
      SerializeAIMemoryEntry = Quantum.AIMemoryEntry.Serialize;
      SerializeAttributeModifier = Quantum.AttributeModifier.Serialize;
      SerializeEAttributeType = (v, s) => {{ s.Stream.Serialize((Byte*)v); }};
      SerializeAttributeData = Quantum.AttributeData.Serialize;
      SerializeEntityRef = EntityRef.Serialize;
      SerializeInt32 = (v, s) => {{ s.Stream.Serialize((Int32*)v); }};
      SerializeTeamData = Quantum.TeamData.Serialize;
      SerializeInput = Quantum.Input.Serialize;
    }
    static partial void RegisterSimulationTypesGen(TypeRegistry typeRegistry) {
      typeRegistry.Register(typeof(AIBlackboardComponent), AIBlackboardComponent.SIZE);
      typeRegistry.Register(typeof(Quantum.AIDirector), Quantum.AIDirector.SIZE);
      typeRegistry.Register(typeof(Quantum.AIDirectorMemory), Quantum.AIDirectorMemory.SIZE);
      typeRegistry.Register(typeof(Quantum.AIMemory), Quantum.AIMemory.SIZE);
      typeRegistry.Register(typeof(Quantum.AIMemoryEntry), Quantum.AIMemoryEntry.SIZE);
      typeRegistry.Register(typeof(Quantum.AISteering), Quantum.AISteering.SIZE);
      typeRegistry.Register(typeof(Quantum.ArcherSpecialAttackRD), Quantum.ArcherSpecialAttackRD.SIZE);
      typeRegistry.Register(typeof(AssetGuid), AssetGuid.SIZE);
      typeRegistry.Register(typeof(AssetRef), AssetRef.SIZE);
      typeRegistry.Register(typeof(Quantum.Attack), Quantum.Attack.SIZE);
      typeRegistry.Register(typeof(Quantum.AttackRuntimeData), Quantum.AttackRuntimeData.SIZE);
      typeRegistry.Register(typeof(Quantum.AttributeData), Quantum.AttributeData.SIZE);
      typeRegistry.Register(typeof(Quantum.AttributeModifier), Quantum.AttributeModifier.SIZE);
      typeRegistry.Register(typeof(Quantum.Attributes), Quantum.Attributes.SIZE);
      typeRegistry.Register(typeof(BTAgent), BTAgent.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet1024), Quantum.BitSet1024.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet128), Quantum.BitSet128.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet2048), Quantum.BitSet2048.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet256), Quantum.BitSet256.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet4096), Quantum.BitSet4096.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet512), Quantum.BitSet512.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet6), Quantum.BitSet6.SIZE);
      typeRegistry.Register(typeof(Quantum.Bot), Quantum.Bot.SIZE);
      typeRegistry.Register(typeof(BotSDKGlobals), BotSDKGlobals.SIZE);
      typeRegistry.Register(typeof(Button), Button.SIZE);
      typeRegistry.Register(typeof(CallbackFlags), 4);
      typeRegistry.Register(typeof(Quantum.Character), Quantum.Character.SIZE);
      typeRegistry.Register(typeof(Quantum.CharacterAttacks), Quantum.CharacterAttacks.SIZE);
      typeRegistry.Register(typeof(CharacterController2D), CharacterController2D.SIZE);
      typeRegistry.Register(typeof(CharacterController3D), CharacterController3D.SIZE);
      typeRegistry.Register(typeof(Quantum.Collectible), Quantum.Collectible.SIZE);
      typeRegistry.Register(typeof(ColorRGBA), ColorRGBA.SIZE);
      typeRegistry.Register(typeof(ComponentPrototypeRef), ComponentPrototypeRef.SIZE);
      typeRegistry.Register(typeof(ComponentTypeRef), ComponentTypeRef.SIZE);
      typeRegistry.Register(typeof(DistanceJoint), DistanceJoint.SIZE);
      typeRegistry.Register(typeof(DistanceJoint3D), DistanceJoint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.EAttributeType), 1);
      typeRegistry.Register(typeof(Quantum.EHealthStatus), 1);
      typeRegistry.Register(typeof(Quantum.EMemoryType), 1);
      typeRegistry.Register(typeof(Quantum.EModifierAppliance), 1);
      typeRegistry.Register(typeof(Quantum.EModifierOperation), 1);
      typeRegistry.Register(typeof(Quantum.ETactics), 1);
      typeRegistry.Register(typeof(Quantum.ETeamStatus), 1);
      typeRegistry.Register(typeof(EntityPrototypeRef), EntityPrototypeRef.SIZE);
      typeRegistry.Register(typeof(EntityRef), EntityRef.SIZE);
      typeRegistry.Register(typeof(Quantum.EscapeRoute), Quantum.EscapeRoute.SIZE);
      typeRegistry.Register(typeof(FP), FP.SIZE);
      typeRegistry.Register(typeof(FPBounds2), FPBounds2.SIZE);
      typeRegistry.Register(typeof(FPBounds3), FPBounds3.SIZE);
      typeRegistry.Register(typeof(FPMatrix2x2), FPMatrix2x2.SIZE);
      typeRegistry.Register(typeof(FPMatrix3x3), FPMatrix3x3.SIZE);
      typeRegistry.Register(typeof(FPMatrix4x4), FPMatrix4x4.SIZE);
      typeRegistry.Register(typeof(FPQuaternion), FPQuaternion.SIZE);
      typeRegistry.Register(typeof(FPVector2), FPVector2.SIZE);
      typeRegistry.Register(typeof(FPVector3), FPVector3.SIZE);
      typeRegistry.Register(typeof(FrameMetaData), FrameMetaData.SIZE);
      typeRegistry.Register(typeof(FrameTimer), FrameTimer.SIZE);
      typeRegistry.Register(typeof(Quantum.GameState), 4);
      typeRegistry.Register(typeof(HFSMAgent), HFSMAgent.SIZE);
      typeRegistry.Register(typeof(HFSMData), HFSMData.SIZE);
      typeRegistry.Register(typeof(Quantum.Health), Quantum.Health.SIZE);
      typeRegistry.Register(typeof(HingeJoint), HingeJoint.SIZE);
      typeRegistry.Register(typeof(HingeJoint3D), HingeJoint3D.SIZE);
      typeRegistry.Register(typeof(Hit), Hit.SIZE);
      typeRegistry.Register(typeof(Hit3D), Hit3D.SIZE);
      typeRegistry.Register(typeof(Quantum.Immunity), Quantum.Immunity.SIZE);
      typeRegistry.Register(typeof(Quantum.Input), Quantum.Input.SIZE);
      typeRegistry.Register(typeof(Quantum.InputButtons), 4);
      typeRegistry.Register(typeof(Quantum.InputContainer), Quantum.InputContainer.SIZE);
      typeRegistry.Register(typeof(IntVector2), IntVector2.SIZE);
      typeRegistry.Register(typeof(IntVector3), IntVector3.SIZE);
      typeRegistry.Register(typeof(Quantum.Inventory), Quantum.Inventory.SIZE);
      typeRegistry.Register(typeof(Quantum.Invisibility), Quantum.Invisibility.SIZE);
      typeRegistry.Register(typeof(Quantum.InvisibilitySpot), Quantum.InvisibilitySpot.SIZE);
      typeRegistry.Register(typeof(Joint), Joint.SIZE);
      typeRegistry.Register(typeof(Joint3D), Joint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.KCC), Quantum.KCC.SIZE);
      typeRegistry.Register(typeof(Quantum.KnightBasicAttackRD), Quantum.KnightBasicAttackRD.SIZE);
      typeRegistry.Register(typeof(Quantum.KnightBasicSkillRD), Quantum.KnightBasicSkillRD.SIZE);
      typeRegistry.Register(typeof(Quantum.KnightSpecialAttackRD), Quantum.KnightSpecialAttackRD.SIZE);
      typeRegistry.Register(typeof(LayerMask), LayerMask.SIZE);
      typeRegistry.Register(typeof(MapEntityId), MapEntityId.SIZE);
      typeRegistry.Register(typeof(MapEntityLink), MapEntityLink.SIZE);
      typeRegistry.Register(typeof(Quantum.MemoryData), Quantum.MemoryData.SIZE);
      typeRegistry.Register(typeof(Quantum.MemoryDataAreaAvoidance), Quantum.MemoryDataAreaAvoidance.SIZE);
      typeRegistry.Register(typeof(Quantum.MemoryDataEnemyInvisible), Quantum.MemoryDataEnemyInvisible.SIZE);
      typeRegistry.Register(typeof(Quantum.MemoryDataLineAvoidance), Quantum.MemoryDataLineAvoidance.SIZE);
      typeRegistry.Register(typeof(Quantum.MovementData), Quantum.MovementData.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceAgent), NavMeshAvoidanceAgent.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceObstacle), NavMeshAvoidanceObstacle.SIZE);
      typeRegistry.Register(typeof(NavMeshPathfinder), NavMeshPathfinder.SIZE);
      typeRegistry.Register(typeof(NavMeshRegionMask), NavMeshRegionMask.SIZE);
      typeRegistry.Register(typeof(NavMeshSteeringAgent), NavMeshSteeringAgent.SIZE);
      typeRegistry.Register(typeof(NullableFP), NullableFP.SIZE);
      typeRegistry.Register(typeof(NullableFPVector2), NullableFPVector2.SIZE);
      typeRegistry.Register(typeof(NullableFPVector3), NullableFPVector3.SIZE);
      typeRegistry.Register(typeof(NullableNonNegativeFP), NullableNonNegativeFP.SIZE);
      typeRegistry.Register(typeof(Quantum.ObjectivePoint), Quantum.ObjectivePoint.SIZE);
      typeRegistry.Register(typeof(PhysicsBody2D), PhysicsBody2D.SIZE);
      typeRegistry.Register(typeof(PhysicsBody3D), PhysicsBody3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks2D), PhysicsCallbacks2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks3D), PhysicsCallbacks3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider2D), PhysicsCollider2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider3D), PhysicsCollider3D.SIZE);
      typeRegistry.Register(typeof(PhysicsEngineState), PhysicsEngineState.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints2D), PhysicsJoints2D.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints3D), PhysicsJoints3D.SIZE);
      typeRegistry.Register(typeof(PhysicsQueryRef), PhysicsQueryRef.SIZE);
      typeRegistry.Register(typeof(PhysicsSceneSettings), PhysicsSceneSettings.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerLink), Quantum.PlayerLink.SIZE);
      typeRegistry.Register(typeof(PlayerRef), PlayerRef.SIZE);
      typeRegistry.Register(typeof(Ptr), Ptr.SIZE);
      typeRegistry.Register(typeof(QBoolean), QBoolean.SIZE);
      typeRegistry.Register(typeof(Quantum.Ptr), Quantum.Ptr.SIZE);
      typeRegistry.Register(typeof(Quantum.QuantumDemoInputPlatformer2D), Quantum.QuantumDemoInputPlatformer2D.SIZE);
      typeRegistry.Register(typeof(Quantum.QuantumDemoInputShooter3D), Quantum.QuantumDemoInputShooter3D.SIZE);
      typeRegistry.Register(typeof(Quantum.QuantumDemoInputTopDown), Quantum.QuantumDemoInputTopDown.SIZE);
      typeRegistry.Register(typeof(Quantum.QuantumHighresThumbSticks), Quantum.QuantumHighresThumbSticks.SIZE);
      typeRegistry.Register(typeof(Quantum.QuantumRegularThumbSticks), Quantum.QuantumRegularThumbSticks.SIZE);
      typeRegistry.Register(typeof(Quantum.QuantumThumbSticks), Quantum.QuantumThumbSticks.SIZE);
      typeRegistry.Register(typeof(QueryOptions), 2);
      typeRegistry.Register(typeof(RNGSession), RNGSession.SIZE);
      typeRegistry.Register(typeof(Quantum.Respawn), Quantum.Respawn.SIZE);
      typeRegistry.Register(typeof(Shape2D), Shape2D.SIZE);
      typeRegistry.Register(typeof(Shape3D), Shape3D.SIZE);
      typeRegistry.Register(typeof(Quantum.Skill), Quantum.Skill.SIZE);
      typeRegistry.Register(typeof(Quantum.SkillRuntimeData), Quantum.SkillRuntimeData.SIZE);
      typeRegistry.Register(typeof(Quantum.SpawnPoint), Quantum.SpawnPoint.SIZE);
      typeRegistry.Register(typeof(Quantum.SpellcasterBasicAttackRD), Quantum.SpellcasterBasicAttackRD.SIZE);
      typeRegistry.Register(typeof(Quantum.SpellcasterSpecialAttackRD), Quantum.SpellcasterSpecialAttackRD.SIZE);
      typeRegistry.Register(typeof(Quantum.SpellcasterSpecialSkillRD), Quantum.SpellcasterSpecialSkillRD.SIZE);
      typeRegistry.Register(typeof(SpringJoint), SpringJoint.SIZE);
      typeRegistry.Register(typeof(SpringJoint3D), SpringJoint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.SteeringData), Quantum.SteeringData.SIZE);
      typeRegistry.Register(typeof(Quantum.SteeringEntryContext), Quantum.SteeringEntryContext.SIZE);
      typeRegistry.Register(typeof(Quantum.SteeringEntryNavMesh), Quantum.SteeringEntryNavMesh.SIZE);
      typeRegistry.Register(typeof(Quantum.TeamData), Quantum.TeamData.SIZE);
      typeRegistry.Register(typeof(Quantum.TeamInfo), Quantum.TeamInfo.SIZE);
      typeRegistry.Register(typeof(Transform2D), Transform2D.SIZE);
      typeRegistry.Register(typeof(Transform2DVertical), Transform2DVertical.SIZE);
      typeRegistry.Register(typeof(Transform3D), Transform3D.SIZE);
      typeRegistry.Register(typeof(UTAgent), UTAgent.SIZE);
      typeRegistry.Register(typeof(View), View.SIZE);
      typeRegistry.Register(typeof(Quantum._globals_), Quantum._globals_.SIZE);
    }
    static partial void InitComponentTypeIdGen() {
      ComponentTypeId.Reset(ComponentTypeId.BuiltInComponentCount + 28)
        .AddBuiltInComponents()
        .Add<AIBlackboardComponent>(AIBlackboardComponent.Serialize, AIBlackboardComponent.OnAdded, AIBlackboardComponent.OnRemoved, ComponentFlags.None)
        .Add<Quantum.AIMemory>(Quantum.AIMemory.Serialize, null, Quantum.AIMemory.OnRemoved, ComponentFlags.None)
        .Add<Quantum.AISteering>(Quantum.AISteering.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Attack>(Quantum.Attack.Serialize, null, Quantum.Attack.OnRemoved, ComponentFlags.None)
        .Add<Quantum.Attributes>(Quantum.Attributes.Serialize, null, Quantum.Attributes.OnRemoved, ComponentFlags.None)
        .Add<BTAgent>(BTAgent.Serialize, BTAgent.OnAdded, BTAgent.OnRemoved, ComponentFlags.None)
        .Add<Quantum.Bot>(Quantum.Bot.Serialize, null, null, ComponentFlags.None)
        .Add<BotSDKGlobals>(BotSDKGlobals.Serialize, BotSDKGlobals.OnAdded, BotSDKGlobals.OnRemoved, ComponentFlags.Singleton)
        .Add<Quantum.Character>(Quantum.Character.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.CharacterAttacks>(Quantum.CharacterAttacks.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Collectible>(Quantum.Collectible.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.EscapeRoute>(Quantum.EscapeRoute.Serialize, null, null, ComponentFlags.None)
        .Add<HFSMAgent>(HFSMAgent.Serialize, HFSMAgent.OnAdded, HFSMAgent.OnRemoved, ComponentFlags.None)
        .Add<Quantum.Health>(Quantum.Health.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Immunity>(Quantum.Immunity.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.InputContainer>(Quantum.InputContainer.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Inventory>(Quantum.Inventory.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Invisibility>(Quantum.Invisibility.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.InvisibilitySpot>(Quantum.InvisibilitySpot.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.KCC>(Quantum.KCC.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.MovementData>(Quantum.MovementData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.ObjectivePoint>(Quantum.ObjectivePoint.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PlayerLink>(Quantum.PlayerLink.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Respawn>(Quantum.Respawn.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Skill>(Quantum.Skill.Serialize, null, Quantum.Skill.OnRemoved, ComponentFlags.None)
        .Add<Quantum.SpawnPoint>(Quantum.SpawnPoint.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.TeamInfo>(Quantum.TeamInfo.Serialize, null, null, ComponentFlags.None)
        .Add<UTAgent>(UTAgent.Serialize, UTAgent.OnAdded, UTAgent.OnRemoved, ComponentFlags.None)
        .Finish();
    }
    [Preserve()]
    public static void EnsureNotStrippedGen() {
      FramePrinter.EnsureNotStripped();
      FramePrinter.EnsurePrimitiveNotStripped<CallbackFlags>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EAttributeType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EHealthStatus>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EMemoryType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EModifierAppliance>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EModifierOperation>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.ETactics>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.ETeamStatus>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.GameState>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.InputButtons>();
      FramePrinter.EnsurePrimitiveNotStripped<QueryOptions>();
    }
  }
}
#pragma warning restore 0109
#pragma warning restore 1591
